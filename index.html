<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Byte vs. The Glitches</title>
  <style>
    :root {
      --bg-classic: #000;
      --bg-modern: radial-gradient(circle at center, #061a3a 0%, #020411 100%);
      --hud-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      --hud-color: #f8f8f8;
      --neon-blue: #24c6ff;
      --trail-blue: rgba(79, 196, 255, 0.4);
      --node-gold: #f4d35e;
      --power-core: #78ffd6;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: var(--bg-modern);
      color: var(--hud-color);
      font-family: var(--hud-font);
      transition: background 0.6s ease;
    }

    body[data-mode="classic"] {
      background: var(--bg-classic);
      color: #fff6b0;
    }

    h1 {
      margin: 24px 0 12px;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-align: center;
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 24px;
      align-items: center;
      justify-content: center;
      padding: 12px 20px;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(6px);
      box-shadow: 0 0 15px rgba(36, 198, 255, 0.35);
    }

    .hud label {
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.9rem;
      letter-spacing: 1px;
    }

    .hud select,
    .hud button {
      background: rgba(10, 18, 46, 0.85);
      color: #f0f7ff;
      border: 1px solid rgba(79, 196, 255, 0.45);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.95rem;
      cursor: pointer;
      transition: border 0.2s ease, background 0.2s ease;
    }

    .hud button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .hud select:hover,
    .hud button:hover,
    .hud select:focus,
    .hud button:focus {
      border-color: rgba(135, 206, 255, 0.85);
      outline: none;
    }

    body[data-mode="classic"] .hud {
      background: rgba(25, 25, 25, 0.65);
      box-shadow: 0 0 15px rgba(255, 216, 0, 0.35);
    }

    body[data-mode="classic"] .hud select,
    body[data-mode="classic"] .hud button {
      background: rgba(22, 22, 22, 0.85);
      border-color: rgba(255, 216, 0, 0.55);
      color: #ffe58d;
    }

    .hud span {
      font-size: 1rem;
      letter-spacing: 1px;
    }

    canvas {
      margin: 24px auto 12px;
      max-width: calc(100vw - 32px);
      border-radius: 16px;
      border: 4px solid rgba(79, 196, 255, 0.75);
      background: #030712;
      box-shadow: 0 0 30px rgba(36, 198, 255, 0.45);
      image-rendering: pixelated;
      transition: box-shadow 0.4s ease, border-color 0.4s ease;
    }

    body[data-mode="classic"] canvas {
      border-color: rgba(255, 216, 0, 0.85);
      box-shadow: 0 0 24px rgba(255, 216, 0, 0.35);
      background: #000;
    }

    .status {
      min-height: 32px;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-size: 0.9rem;
      margin-bottom: 16px;
      text-align: center;
    }

    .legend {
      max-width: 820px;
      padding: 0 24px 32px;
      opacity: 0.85;
      line-height: 1.6;
    }

    .legend strong {
      color: #8be9ff;
    }

    body[data-mode="classic"] .legend strong {
      color: #ffd400;
    }
  </style>
</head>
<body>
  <h1>Byte vs. The Glitches</h1>
  <div class="hud">
    <label for="mode-select">Mode</label>
    <select id="mode-select">
      <option value="modern">Modern Mode</option>
      <option value="classic">Classic Mode</option>
    </select>
    <span>Score: <strong id="score">0</strong></span>
    <span>Lives: <strong id="lives">3</strong></span>
    <button id="save-html" type="button" aria-label="Download the current game HTML">Save HTML</button>
  </div>
  <canvas id="game" width="704" height="576" aria-label="Byte navigating a neon maze"></canvas>
  <div id="status" class="status"></div>
  <div class="legend">
    <p><strong>Modern Mode:</strong> Guide Byte, a luminous data spirit, through neon tunnels. Gather Energy Nodes, overclock with radiant cores, and turn the Glitches vulnerable before they rewrite reality.</p>
    <p><strong>Classic Mode:</strong> Relive a retro remix. Classic pellets, iconic colors, timeless tension.</p>
  </div>
  <script>
    const TILE_SIZE = 32;
    const LAYOUT = [
      "######################",
      "#..........##........#",
      "#.####.###.##.###.####",
      "#o###.###.##.###.###o#",
      "#....................#",
      "#.###.##.####.##.###.#",
      "#......##....##......#",
      "#######.######.#######",
      "     #.#      #.#     ",
      "#### #.# #### #.# ####",
      "#..........##........#",
      "#.####.###.##.###.####",
      "#o..##...........##.o#",
      "###.##.##.##.##.##.###",
      "#......##....##......#",
      "#.##############.###.#",
      "#....................#",
      "######################"
    ];

    const COLS = LAYOUT[0].length;
    const ROWS = LAYOUT.length;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = COLS * TILE_SIZE;
    canvas.height = ROWS * TILE_SIZE;

    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const statusEl = document.getElementById('status');
    const modeSelect = document.getElementById('mode-select');
    const saveButton = document.getElementById('save-html');

    const DIRECTIONS = {
      ArrowUp: { x: 0, y: -1 },
      ArrowDown: { x: 0, y: 1 },
      ArrowLeft: { x: -1, y: 0 },
      ArrowRight: { x: 1, y: 0 }
    };

    const MODE_SEQUENCE = [
      { state: 'scatter', duration: 7 },
      { state: 'chase', duration: 20 },
      { state: 'scatter', duration: 7 },
      { state: 'chase', duration: 20 }
    ];

    const POINTS = {
      classic: { node: 10, core: 50, enemy: 200 },
      modern: { node: 15, core: 75, enemy: 250 }
    };

    const PLAYER_START = { col: 11, row: 13 };
    const ENEMY_STARTS = [
      { col: 10, row: 8 },
      { col: 11, row: 8 },
      { col: 12, row: 8 },
      { col: 11, row: 9 }
    ];

    const CLASSIC_ENEMY_DEFS = [
      {
        name: 'Blinky',
        color: '#ff4136',
        scatterTarget: { x: TILE_SIZE * (COLS - 2), y: TILE_SIZE * 1 },
        behavior: 'chase',
        type: ClassicGhost
      },
      {
        name: 'Pinky',
        color: '#ff7eb9',
        scatterTarget: { x: TILE_SIZE * 1, y: TILE_SIZE * 1 },
        behavior: 'ambush',
        type: ClassicGhost
      },
      {
        name: 'Inky',
        color: '#00cbe6',
        scatterTarget: { x: TILE_SIZE * (COLS - 2), y: TILE_SIZE * (ROWS - 2) },
        behavior: 'phase',
        type: ClassicGhost
      },
      {
        name: 'Clyde',
        color: '#ffb347',
        scatterTarget: { x: TILE_SIZE * 1, y: TILE_SIZE * (ROWS - 2) },
        behavior: 'random',
        type: ClassicGhost
      }
    ];

    const GLITCH_DEFS = [
      {
        name: 'Static Wraith',
        color: '#ae5cff',
        scatterTarget: { x: TILE_SIZE * 1, y: TILE_SIZE * 1 },
        behavior: 'phase',
        type: StaticWraith
      },
      {
        name: 'Neon Phantom',
        color: '#ff4fe1',
        scatterTarget: { x: TILE_SIZE * (COLS - 2), y: TILE_SIZE * 1 },
        behavior: 'chase',
        type: NeonPhantom
      },
      {
        name: 'Crystalline Shard',
        color: '#4ae4ff',
        scatterTarget: { x: TILE_SIZE * 1, y: TILE_SIZE * (ROWS - 2) },
        behavior: 'ambush',
        type: CrystallineShard
      },
      {
        name: 'Inferno Bug',
        color: '#ff8933',
        scatterTarget: { x: TILE_SIZE * (COLS - 2), y: TILE_SIZE * (ROWS - 2) },
        behavior: 'random',
        type: InfernoBug
      }
    ];

    let collectibleGrid = [];
    let collectibleCount = 0;
    let currentMode = 'modern';
    let score = 0;
    let lives = 3;
    let powerTimer = 0;
    let comboMultiplier = 0;
    let player;
    let enemies = [];
    let lastTime = performance.now();
    let running = false;
    let gameState = 'playing';
    let phaseIndex = 0;
    let phaseTimer = MODE_SEQUENCE[0].duration;
    let globalPhase = MODE_SEQUENCE[0].state;

    class PlayerBase {
      constructor(col, row) {
        this.startCol = col;
        this.startRow = row;
        this.speed = 120;
        this.reset();
      }

      reset() {
        this.x = (this.startCol + 0.5) * TILE_SIZE;
        this.y = (this.startRow + 0.5) * TILE_SIZE;
        this.direction = { x: 0, y: 0 };
        this.nextDirection = null;
        this.trail = [];
      }

      update(dt) {
        const center = this.getTileCenter();
        if (this.nextDirection && this.canMove(this.nextDirection) && this.isCloseTo(center.x, center.y)) {
          this.direction = this.nextDirection;
          this.nextDirection = null;
        }

        const velocity = this.speed * dt;
        const nextX = this.x + this.direction.x * velocity;
        const nextY = this.y + this.direction.y * velocity;

        if (!this.collides(nextX, nextY)) {
          this.x = nextX;
          this.y = nextY;
        } else {
          if (Math.abs(this.x - center.x) < 2) this.x = center.x;
          if (Math.abs(this.y - center.y) < 2) this.y = center.y;
          this.direction = { x: 0, y: 0 };
        }

        this.wrap();
        this.updateTrail(dt);
      }

      handleInput(dir) {
        if (!dir) return;
        if (!this.direction.x && !this.direction.y && this.canMove(dir)) {
          this.direction = dir;
          this.nextDirection = null;
          return;
        }
        if (this.direction.x === -dir.x && this.direction.y === -dir.y) {
          this.direction = dir;
          return;
        }
        this.nextDirection = dir;
      }

      getTile() {
        return {
          col: Math.floor(this.x / TILE_SIZE),
          row: Math.floor(this.y / TILE_SIZE)
        };
      }

      getTileCenter() {
        const { col, row } = this.getTile();
        return {
          x: (col + 0.5) * TILE_SIZE,
          y: (row + 0.5) * TILE_SIZE
        };
      }

      isCloseTo(x, y) {
        return Math.abs(this.x - x) < 2 && Math.abs(this.y - y) < 2;
      }

      canMove(dir) {
        const { col, row } = this.getTile();
        const nextCol = col + dir.x;
        const nextRow = row + dir.y;
        return !isWall(nextCol, nextRow);
      }

      collides(nextX, nextY) {
        const half = TILE_SIZE * 0.35;
        const points = [
          { x: nextX - half, y: nextY - half },
          { x: nextX + half, y: nextY - half },
          { x: nextX - half, y: nextY + half },
          { x: nextX + half, y: nextY + half }
        ];
        return points.some((p) => isWallAtPixel(p.x, p.y));
      }

      wrap() {
        if (this.x < -TILE_SIZE * 0.5) this.x = canvas.width + TILE_SIZE * 0.5;
        if (this.x > canvas.width + TILE_SIZE * 0.5) this.x = -TILE_SIZE * 0.5;
      }

      updateTrail(dt) {
        if (this.direction.x || this.direction.y) {
          this.trail.unshift({ x: this.x, y: this.y, life: 0.65 });
        }
        this.trail.forEach((segment) => {
          segment.life -= dt;
        });
        this.trail = this.trail.filter((segment, index) => segment.life > 0 && index < 16);
      }

      draw() {
        throw new Error('draw() must be implemented by subclasses');
      }
    }

    class ClassicPlayer extends PlayerBase {
      draw() {
        const angle = Math.PI / 6;
        const rotation = Math.atan2(this.direction.y, this.direction.x) || 0;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(rotation);
        ctx.fillStyle = '#ffd21f';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, TILE_SIZE * 0.45, angle, Math.PI * 2 - angle);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    class BytePlayer extends PlayerBase {
      draw(timestamp) {
        this.trail.forEach((segment, index) => {
          const alpha = Math.max(0, segment.life);
          if (!alpha) return;
          ctx.save();
          ctx.globalAlpha = alpha * (0.85 - index * 0.04);
          const grad = ctx.createRadialGradient(segment.x, segment.y, 0, segment.x, segment.y, TILE_SIZE * 0.6);
          grad.addColorStop(0, 'rgba(180, 240, 255, 0.9)');
          grad.addColorStop(1, 'rgba(40, 120, 255, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(segment.x, segment.y, TILE_SIZE * 0.58, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });

        const flicker = 0.65 + 0.35 * Math.sin(timestamp / 120);
        const fracture = Math.sin(timestamp / 90) * Math.PI / 8;
        ctx.save();
        ctx.translate(this.x, this.y);
        const orb = ctx.createRadialGradient(0, 0, 4, 0, 0, TILE_SIZE * 0.52);
        orb.addColorStop(0, 'rgba(200, 255, 255, 1)');
        orb.addColorStop(0.6, `rgba(90, 210, 255, ${flicker})`);
        orb.addColorStop(1, 'rgba(2, 12, 40, 0.05)');
        ctx.fillStyle = orb;
        ctx.beginPath();
        ctx.arc(0, 0, TILE_SIZE * 0.52, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = `rgba(120, 225, 255, ${0.75 + 0.15 * Math.sin(timestamp / 80)})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, TILE_SIZE * 0.52, Math.PI / 6 + fracture, Math.PI * 2 - Math.PI / 6 + fracture);
        ctx.stroke();

        ctx.beginPath();
        ctx.fillStyle = 'rgba(205, 255, 255, 0.65)';
        ctx.arc(0, 0, TILE_SIZE * 0.26, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class EnemyBase {
      constructor(def, start) {
        this.definition = def;
        this.startCol = start.col;
        this.startRow = start.row;
        this.baseSpeed = 90;
        this.animationOffset = Math.random() * 2000;
        this.reset();
      }

      reset() {
        this.x = (this.startCol + 0.5) * TILE_SIZE;
        this.y = (this.startRow + 0.5) * TILE_SIZE;
        this.direction = { x: 0, y: -1 };
        this.isFrightened = false;
      }

      setFrightened() {
        this.isFrightened = true;
      }

      clearFrightened() {
        this.isFrightened = false;
      }

      update(dt) {
        const speed = (this.isFrightened ? this.baseSpeed * 0.65 : this.baseSpeed) * dt;
        const nextX = this.x + this.direction.x * speed;
        const nextY = this.y + this.direction.y * speed;
        if (!this.collides(nextX, nextY)) {
          this.x = nextX;
          this.y = nextY;
        }

        this.wrap();
        this.chooseDirection();
      }

      getTile() {
        return {
          col: Math.floor(this.x / TILE_SIZE),
          row: Math.floor(this.y / TILE_SIZE)
        };
      }

      collides(x, y) {
        const half = TILE_SIZE * 0.35;
        const points = [
          { x: x - half, y: y - half },
          { x: x + half, y: y - half },
          { x: x - half, y: y + half },
          { x: x + half, y: y + half }
        ];
        return points.some((p) => isWallAtPixel(p.x, p.y));
      }

      wrap() {
        if (this.x < -TILE_SIZE * 0.5) this.x = canvas.width + TILE_SIZE * 0.5;
        if (this.x > canvas.width + TILE_SIZE * 0.5) this.x = -TILE_SIZE * 0.5;
      }

      chooseDirection() {
        const { col, row } = this.getTile();
        const options = getAvailableDirections(col, row, this.direction);
        if (!options.length) {
          this.direction = { x: -this.direction.x, y: -this.direction.y };
          return;
        }

        if (this.isFrightened) {
          let farthest = options[0];
          let maxDistance = -Infinity;
          options.forEach((dir) => {
            const target = tileToPixel(col + dir.x, row + dir.y);
            const dist = distance(target.x, target.y, player.x, player.y);
            if (dist > maxDistance) {
              maxDistance = dist;
              farthest = dir;
            }
          });
          this.direction = farthest;
          return;
        }

        if (this.definition.behavior === 'random') {
          this.direction = options[Math.floor(Math.random() * options.length)];
          return;
        }

        const target = this.getTarget();
        let best = options[0];
        let bestDist = Infinity;
        options.forEach((dir) => {
          const candidate = tileToPixel(col + dir.x, row + dir.y);
          const dist = distance(candidate.x, candidate.y, target.x, target.y);
          if (dist < bestDist) {
            bestDist = dist;
            best = dir;
          }
        });
        this.direction = best;
      }

      getTarget() {
        const scatter = this.definition.scatterTarget;
        if (this.definition.behavior === 'phase') {
          return globalPhase === 'scatter' ? scatter : { x: player.x, y: player.y };
        }
        if (this.definition.behavior === 'ambush') {
          const lookAhead = 4;
          return globalPhase === 'scatter'
            ? scatter
            : {
                x: player.x + player.direction.x * lookAhead * TILE_SIZE,
                y: player.y + player.direction.y * lookAhead * TILE_SIZE
              };
        }
        return { x: player.x, y: player.y };
      }

      draw() {
        throw new Error('draw() must be implemented by subclasses');
      }
    }

    class ClassicGhost extends EnemyBase {
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        const color = this.isFrightened ? '#2b9cff' : this.definition.color;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, -TILE_SIZE * 0.05, TILE_SIZE * 0.45, Math.PI, 0);
        ctx.lineTo(TILE_SIZE * 0.45, TILE_SIZE * 0.45);
        ctx.lineTo(TILE_SIZE * 0.25, TILE_SIZE * 0.35);
        ctx.lineTo(0, TILE_SIZE * 0.45);
        ctx.lineTo(-TILE_SIZE * 0.25, TILE_SIZE * 0.35);
        ctx.lineTo(-TILE_SIZE * 0.45, TILE_SIZE * 0.45);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-TILE_SIZE * 0.15, -TILE_SIZE * 0.18, TILE_SIZE * 0.12, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(TILE_SIZE * 0.15, -TILE_SIZE * 0.18, TILE_SIZE * 0.12, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#032b4f';
        ctx.beginPath();
        ctx.arc(-TILE_SIZE * 0.1, -TILE_SIZE * 0.15, TILE_SIZE * 0.05, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(TILE_SIZE * 0.1, -TILE_SIZE * 0.15, TILE_SIZE * 0.05, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class StaticWraith extends EnemyBase {
      draw(timestamp) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const alpha = this.isFrightened ? 0.4 : 0.55 + 0.3 * Math.sin((timestamp + this.animationOffset) / 90);
        ctx.globalAlpha = alpha;
        const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, TILE_SIZE * 0.55);
        gradient.addColorStop(0, '#cbbdff');
        gradient.addColorStop(0.6, this.isFrightened ? '#7ae4ff' : '#7f3cff');
        gradient.addColorStop(1, 'rgba(20, 0, 40, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, TILE_SIZE * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        for (let i = 0; i < 5; i++) {
          const noiseX = (Math.random() - 0.5) * TILE_SIZE * 0.2;
          const noiseY = (Math.random() - 0.5) * TILE_SIZE * 0.2;
          ctx.strokeRect(noiseX - TILE_SIZE * 0.15, noiseY - TILE_SIZE * 0.15, TILE_SIZE * 0.3, TILE_SIZE * 0.3);
        }
        ctx.restore();
      }
    }

    class NeonPhantom extends EnemyBase {
      draw(timestamp) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const pulse = 0.5 + 0.5 * Math.sin((timestamp + this.animationOffset) / 150);
        ctx.globalAlpha = this.isFrightened ? 0.45 : 0.7 + 0.25 * pulse;
        ctx.lineWidth = 4;
        ctx.strokeStyle = this.isFrightened ? '#78ffd6' : '#ff4fe1';
        ctx.shadowBlur = 18;
        ctx.shadowColor = ctx.strokeStyle;
        ctx.beginPath();
        ctx.arc(0, 0, TILE_SIZE * 0.48, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }

    class CrystallineShard extends EnemyBase {
      draw(timestamp) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const pulse = 0.5 + 0.5 * Math.sin((timestamp + this.animationOffset) / 150);
        const facets = 6;
        const radius = TILE_SIZE * 0.48;
        ctx.fillStyle = this.isFrightened ? 'rgba(120, 255, 230, 0.85)' : 'rgba(74, 228, 255, 0.85)';
        ctx.beginPath();
        for (let i = 0; i < facets; i++) {
          const angle = (Math.PI * 2 * i) / facets + pulse * 0.2;
          const r = radius * (i % 2 === 0 ? 1 : 0.6);
          const px = Math.cos(angle) * r;
          const py = Math.sin(angle) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = 'rgba(210,255,255,0.8)';
        ctx.lineWidth = 2;
        ctx.stroke();
        for (let i = 0; i < 3; i++) {
          const angle = timestamp / 250 + i * (Math.PI * 2 / 3);
          ctx.beginPath();
          ctx.fillStyle = 'rgba(210,255,255,0.65)';
          ctx.arc(Math.cos(angle) * radius * 0.75, Math.sin(angle) * radius * 0.75, TILE_SIZE * 0.12, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    class InfernoBug extends EnemyBase {
      draw(timestamp) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const pulse = 0.5 + 0.5 * Math.sin((timestamp + this.animationOffset) / 150);
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, TILE_SIZE * 0.55);
        const outer = this.isFrightened ? '#7ef5ff' : '#ff7b2f';
        gradient.addColorStop(0, '#fff1cf');
        gradient.addColorStop(0.45, this.isFrightened ? '#f4ffe1' : '#ffb347');
        gradient.addColorStop(1, `${outer}00`);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, TILE_SIZE * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowColor = this.isFrightened ? '#7ef5ff' : '#ff5c00';
        ctx.shadowBlur = 24;
        ctx.beginPath();
        ctx.moveTo(-TILE_SIZE * 0.22, TILE_SIZE * (0.3 + 0.1 * pulse));
        ctx.lineTo(0, TILE_SIZE * (0.45 + 0.15 * pulse));
        ctx.lineTo(TILE_SIZE * 0.22, TILE_SIZE * (0.3 + 0.1 * pulse));
        ctx.lineWidth = 3;
        ctx.strokeStyle = this.isFrightened ? '#9effff' : '#ff7c3a';
        ctx.stroke();
        ctx.restore();
      }
    }

    function createCollectibles() {
      collectibleGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      collectibleCount = 0;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const cell = LAYOUT[row][col];
          if (cell === '.' || cell === 'o') {
            collectibleGrid[row][col] = {
              type: cell === '.' ? 'node' : 'core',
              consumed: false
            };
            collectibleCount++;
          }
        }
      }
    }

    function isWall(col, row) {
      if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return true;
      return LAYOUT[row][col] === '#';
    }

    function isWallAtPixel(px, py) {
      const col = Math.floor(px / TILE_SIZE);
      const row = Math.floor(py / TILE_SIZE);
      return isWall(col, row);
    }

    function tileToPixel(col, row) {
      return { x: (col + 0.5) * TILE_SIZE, y: (row + 0.5) * TILE_SIZE };
    }

    function getAvailableDirections(col, row, currentDir) {
      const directions = [
        { x: 0, y: -1 },
        { x: 0, y: 1 },
        { x: -1, y: 0 },
        { x: 1, y: 0 }
      ];
      const options = [];
      for (const dir of directions) {
        if (currentDir && dir.x === -currentDir.x && dir.y === -currentDir.y) continue;
        if (!isWall(col + dir.x, row + dir.y)) options.push(dir);
      }
      return options;
    }

    function distance(x1, y1, x2, y2) {
      const dx = x1 - x2;
      const dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function drawMaze() {
      ctx.fillStyle = currentMode === 'classic' ? '#000' : '#01020c';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const x = col * TILE_SIZE;
          const y = row * TILE_SIZE;
          if (LAYOUT[row][col] === '#') {
            const wallGradient = ctx.createLinearGradient(x, y, x + TILE_SIZE, y + TILE_SIZE);
            if (currentMode === 'classic') {
              wallGradient.addColorStop(0, '#003cff');
              wallGradient.addColorStop(1, '#001966');
            } else {
              wallGradient.addColorStop(0, '#06224f');
              wallGradient.addColorStop(1, '#021228');
            }
            ctx.fillStyle = wallGradient;
            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            if (currentMode === 'modern') {
              ctx.strokeStyle = 'rgba(36, 198, 255, 0.35)';
              ctx.lineWidth = 2;
              ctx.strokeRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6);
            }
          } else if (currentMode === 'modern') {
            ctx.fillStyle = 'rgba(36, 198, 255, 0.08)';
            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = 'rgba(36, 198, 255, 0.12)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.3, TILE_SIZE * 0.4, TILE_SIZE * 0.4);
          }
        }
      }
    }

    function drawCollectibles(timestamp) {
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const collectible = collectibleGrid[row][col];
          if (!collectible || collectible.consumed) continue;
          const x = (col + 0.5) * TILE_SIZE;
          const y = (row + 0.5) * TILE_SIZE;
          if (collectible.type === 'node') {
            if (currentMode === 'classic') {
              ctx.fillStyle = '#ffd54f';
              ctx.beginPath();
              ctx.arc(x, y, TILE_SIZE * 0.15, 0, Math.PI * 2);
              ctx.fill();
            } else {
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate((Math.sin(timestamp / 200 + row + col) * Math.PI) / 12);
              ctx.fillStyle = '#f4d35e';
              ctx.beginPath();
              ctx.moveTo(0, -TILE_SIZE * 0.18);
              ctx.lineTo(TILE_SIZE * 0.18, 0);
              ctx.lineTo(0, TILE_SIZE * 0.18);
              ctx.lineTo(-TILE_SIZE * 0.18, 0);
              ctx.closePath();
              ctx.fill();
              ctx.restore();
            }
          } else {
            if (currentMode === 'classic') {
              ctx.fillStyle = '#fff';
              ctx.beginPath();
              ctx.arc(x, y, TILE_SIZE * 0.28, 0, Math.PI * 2);
              ctx.fill();
            } else {
              const glow = ctx.createRadialGradient(x, y, 4, x, y, TILE_SIZE * 0.4);
              glow.addColorStop(0, '#f5fff6');
              glow.addColorStop(0.4, '#78ffd6');
              glow.addColorStop(1, 'rgba(120, 255, 214, 0)');
              ctx.fillStyle = glow;
              ctx.beginPath();
              ctx.arc(x, y, TILE_SIZE * 0.4 + Math.sin(timestamp / 200) * 1.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
      }
    }

    function updatePhase(dt) {
      phaseTimer -= dt;
      if (phaseTimer <= 0) {
        phaseIndex = (phaseIndex + 1) % MODE_SEQUENCE.length;
        globalPhase = MODE_SEQUENCE[phaseIndex].state;
        phaseTimer = MODE_SEQUENCE[phaseIndex].duration;
      }
    }

    function update(dt) {
      updatePhase(dt);
      if (powerTimer > 0) {
        powerTimer -= dt;
        if (powerTimer <= 0) {
          enemies.forEach((enemy) => enemy.clearFrightened());
          comboMultiplier = 0;
        }
      }

      player.update(dt);
      handleCollectibleConsumption();
      enemies.forEach((enemy) => enemy.update(dt));
      handleEnemyCollisions();
    }

    function resetEntities() {
      createCollectibles();
      player = currentMode === 'classic'
        ? new ClassicPlayer(PLAYER_START.col, PLAYER_START.row)
        : new BytePlayer(PLAYER_START.col, PLAYER_START.row);
      const definitions = currentMode === 'classic' ? CLASSIC_ENEMY_DEFS : GLITCH_DEFS;
      enemies = definitions.map((def, index) => {
        const start = ENEMY_STARTS[index % ENEMY_STARTS.length];
        return new def.type(def, start);
      });
    }

    function handleCollectibleConsumption() {
      const { col, row } = player.getTile();
      const collectible = collectibleGrid[row]?.[col];
      if (!collectible || collectible.consumed) return;
      const center = { x: (col + 0.5) * TILE_SIZE, y: (row + 0.5) * TILE_SIZE };
      if (!player.isCloseTo(center.x, center.y)) return;
      collectible.consumed = true;
      collectibleCount--;
      if (collectible.type === 'node') {
        score += POINTS[currentMode].node;
      } else {
        score += POINTS[currentMode].core;
        powerTimer = 7;
        comboMultiplier = 0;
        enemies.forEach((enemy) => enemy.setFrightened());
      }
      updateScore();
      if (collectibleCount === 0) {
        winGame();
      }
    }

    function handleEnemyCollisions() {
      for (const enemy of enemies) {
        const dist = distance(player.x, player.y, enemy.x, enemy.y);
        if (dist < TILE_SIZE * 0.5) {
          if (enemy.isFrightened) {
            enemy.reset();
            comboMultiplier++;
            const bonus = Math.max(1, comboMultiplier);
            score += POINTS[currentMode].enemy * bonus;
            updateScore();
          } else {
            loseLife();
            break;
          }
        }
      }
    }

    function loseLife() {
      if (gameState !== 'playing') return;
      lives--;
      updateLives();
      if (lives <= 0) {
        gameOver('The Glitches rewrote the maze. Press Enter to reboot.');
        return;
      }
      statusEl.textContent = 'Byte regroups...';
      powerTimer = 0;
      comboMultiplier = 0;
      player.reset();
      enemies.forEach((enemy) => enemy.reset());
    }

    function winGame() {
      gameState = 'won';
      statusEl.textContent = 'Maze stabilized! Press Enter for another run.';
    }

    function gameOver(message) {
      gameState = 'over';
      statusEl.textContent = message;
    }

    function draw(timestamp) {
      drawMaze();
      drawCollectibles(timestamp);
      player.draw(timestamp);
      enemies.forEach((enemy) => enemy.draw(timestamp));
      if (gameState !== 'playing') {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.45)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function updateScore() {
      scoreEl.textContent = score;
    }

    function updateLives() {
      livesEl.textContent = lives;
    }

    function loop(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      if (gameState === 'playing') {
        update(dt);
      }
      draw(timestamp);
      if (running) {
        requestAnimationFrame(loop);
      }
    }

    function initGame(mode = currentMode) {
      currentMode = mode;
      modeSelect.value = mode;
      document.body.dataset.mode = mode;
      score = 0;
      lives = 3;
      powerTimer = 0;
      comboMultiplier = 0;
      resetEntities();
      gameState = 'playing';
      phaseIndex = 0;
      phaseTimer = MODE_SEQUENCE[0].duration;
      globalPhase = MODE_SEQUENCE[0].state;
      updateScore();
      updateLives();
      statusEl.textContent =
        currentMode === 'classic'
          ? 'Chomp every pellet before the ghosts corner you!'
          : 'Collect every node to stabilize the sector!';
      lastTime = performance.now();
      if (!running) {
        running = true;
        requestAnimationFrame(loop);
      }
    }

    modeSelect.addEventListener('change', () => {
      initGame(modeSelect.value);
    });

    if (saveButton) {
      saveButton.addEventListener('click', () => {
        const docType = '<!DOCTYPE html>\n';
        const html = document.documentElement.outerHTML;
        const blob = new Blob([docType, html], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const download = document.createElement('a');
        const mode = document.body.dataset.mode || currentMode;
        download.href = url;
        download.download = `byte-vs-glitches-${mode}.html`;
        document.body.appendChild(download);
        download.click();
        download.remove();
        URL.revokeObjectURL(url);
      });
    }

    window.addEventListener('keydown', (event) => {
      if (DIRECTIONS[event.key]) {
        event.preventDefault();
        if (player) player.handleInput(DIRECTIONS[event.key]);
      }
      if (event.key === 'Enter' && gameState !== 'playing') {
        initGame(currentMode);
      }
    });

    initGame('modern');
  </script>
</body>
</html>
